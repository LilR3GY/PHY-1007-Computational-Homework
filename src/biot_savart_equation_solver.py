from re import I
import numpy as np
from scipy.constants import mu_0, pi

from src.fields import VectorField


class BiotSavartEquationSolver:
    """
    A Biot–Savart law solver used to compute the resultant magnetic field B in 2D-space generated by a constant current
    field I (for example due to wires).
    """

    def solve(self, electric_current: VectorField) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (x, y) → (I_x(x, y), I_y(x, y), I_z(x, y)), where I_x(x, y), I_y(x, y) and
            I_z(x, y) are the 3 components of the electric current vector at a given point (x, y) in space. Note that
            I_z = 0 is always True in our 2D world.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (x, y) → (B_x(x, y), B_y(x, y), B_z(x, y)), where B_x(x, y), B_y(x, y) and
            B_z(x, y) are the 3 components of the magnetic vector at a given point (x, y) in space. Note that
            B_x = B_y = 0 is always True in our 2D world.
        """
        import time
        import warnings

        #On créer une matrice d'indice n et m
        n, m, _ = electric_current.shape
        magnetic_field = np.zeros(electric_current.shape)

        r_i, r_j = np.indices((n, m))
        #On itère sur notre matrice créer à la ligne 39, en calculant nos distance à l'aide d'une matrice d'indice.
        for i in range(n):
            for j in range(m):

                #En utilisant stack, on joint nos deux matrices.
                #Par la suite, on calcul les valeurs requises pour faire Biot-Savart
                r = np.stack([i-r_i, j-r_j, np.zeros((n, m))], axis=2)
                r_norm = np.sqrt(np.sum(np.square(r), axis=2))
                r_hat = r/r_norm[:, :, None]
                
                #Valeur de notre champs avant l'ajout des constantes
                b = np.cross(electric_current, r_hat, axis=2)/np.square(r_norm)[:, :, None]


                #À cause des discontinuités causé par une norme = 0, il faut «manuellement» mettre ces itérations = 0 pour que le code fonctionne.
                #Cependant, le code renvoi quand même une erreur, mais marche quand même.
                b[np.isnan(b)] = 0

                #Valeur de notre matrice de champs B en tous points dans le monde
                magnetic_field[i, j] = (mu_0/(4*pi))*np.sum(b, axis=(0, 1))

        return VectorField(magnetic_field)